// Generated by CoffeeScript 1.6.3
(function() {
  var $mainCanvas, FloatBuffer, Layer, Point, Rect, assert, assertEqual, changeGamma, createCanvas, drawing, gamma, getMainContext, getPenPressure, height, layer, offset, onDraw, refresh, width;

  $mainCanvas = $('#canvas');

  width = $mainCanvas.width();

  height = $mainCanvas.height();

  assert = function(b) {
    if (!b) {
      throw "Assertion failed";
    }
  };

  assertEqual = function(a, b) {
    if (a !== b) {
      throw "Assertion failed: " + a + " != " + b;
    }
  };

  createCanvas = function(width, height) {
    var c;
    c = document.createElement('canvas');
    c.width = width;
    c.height = height;
    return c;
  };

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Rect = (function() {
    var a, b;

    function Rect(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }

    Rect.prototype.intersect = function(rect) {
      var nmaxx, nmaxy, nx, ny;
      nmaxx = Math.min(this.x + this.width, rect.x + rect.width);
      nmaxy = Math.min(this.x + this.width, rect.x + rect.width);
      nx = Math.max(this.x, rect.x);
      ny = Math.max(this.y, rect.y);
      return new Rect(nx, ny, Math.max(0, nmaxx - nx), Math.max(0, nmaxy - ny));
    };

    a = new Rect(10, 20, 100, 100);

    b = new Rect(20, 10, 100, 100);

    assertEqual(a.intersect(b).width, 90);

    assertEqual(b.intersect(a).width, 90);

    assertEqual(a.intersect(b).height, 90);

    assertEqual(b.intersect(a).height, 90);

    a = new Rect(0, 0, 100, 100);

    b = new Rect(200, 50, 100, 100);

    assertEqual(a.intersect(b).width, 0);

    assertEqual(b.intersect(a).height, 50);

    return Rect;

  })();

  FloatBuffer = (function() {
    function FloatBuffer(width, height) {
      this.width = width;
      this.height = height;
      this.buffer = new ArrayBuffer(this.width * this.height * 4);
      this.fbuffer = new Float32Array(this.buffer);
    }

    return FloatBuffer;

  })();

  Layer = (function() {
    function Layer(width, height) {
      this.width = width;
      this.height = height;
      this.fbuffer = new FloatBuffer(this.width, this.height);
      this.canvas = createCanvas(this.width, this.height);
      this.context = this.canvas.getContext('2d');
      this.imageData = this.context.getImageData(0, 0, width, height);
    }

    return Layer;

  })();

  drawing = false;

  gamma = 1.0;

  layer = new Layer(width, height);

  offset = new Point(50, 30);

  
function updateLayer (layer, rects, gamma) {
  var width = layer.width;
  var height = layer.height;
  var data = layer.imageData.data;
  var fb = layer.fbuffer;
  for(var i in rects) {
    var r = rects[i];
    var minX = r[0];
    var minY = r[1];
    var maxX = minX + r[2];
    var maxY = minY + r[3];
    for(var iy=minY; iy<maxY; ++iy) {
      var offset = iy * width;
      for(var ix=minX; ix<maxX; ++ix) {
        var fval = fb[offset + ix];
        var val = Math.pow((fval + 1.0) * 0.5, gamma) * 255.0;
        var i = (offset + ix) << 2;
        data[i] = val;
        data[++i] = val;
        data[++i] = val;
        data[++i] = 0xff;
      }
    }

    layer.context.putImageData(layer.imageData, 0, 0, r[0], r[1], r[2], r[3])
  }
}

function fillLayer(layer, func) {
  var width = layer.width;
  var height = layer.height;
  var invw = 1.0 / width;
  var invh = 1.0 / height;
  var fb = layer.fbuffer;
  for(var iy=0; iy<height; ++iy) {
    var off = iy * width;
    for(var ix=0; ix<width; ++ix) {
      fb[off + ix] = func(ix * invw, iy * invh);
    }
  }
}
;

  getMainContext = function() {
    return $mainCanvas[0].getContext('2d');
  };

  getPenPressure = function() {
    var penAPI, plugin;
    plugin = document.getElementById('wtPlugin');
    penAPI = plugin.penAPI;
    if (penAPI && penAPI.pointerType > 0) {
      return penAPI.pressure;
    }
    return 1.0;
  };

  onDraw = function(e) {
    var brushH, brushRect, brushW, brushX, brushY, fb, i, ix, iy, pressure, _i, _j;
    brushX = e.pageX - $mainCanvas.position().left - offset.x;
    brushY = e.pageY - $mainCanvas.position().top - offset.y;
    brushW = 30;
    brushH = 20;
    pressure = getPenPressure();
    fb = layer.fbuffer;
    for (ix = _i = 0; 0 <= brushW ? _i <= brushW : _i >= brushW; ix = 0 <= brushW ? ++_i : --_i) {
      for (iy = _j = 0; 0 <= brushH ? _j <= brushH : _j >= brushH; iy = 0 <= brushH ? ++_j : --_j) {
        i = brushX + ix + (brushY + iy) * width;
        fb[i] += pressure * 0.2;
      }
    }
    brushRect = [brushX, brushY, brushW + 1, brushH + 1];
    updateLayer(layer, [brushRect], gamma);
    return getMainContext().drawImage(layer.canvas, brushRect[0], brushRect[1], brushRect[2], brushRect[3], offset.x + brushRect[0], offset.y + brushRect[1], brushRect[2], brushRect[3]);
  };

  changeGamma = function(value) {
    gamma = value;
    return refresh();
  };

  refresh = function() {
    updateLayer(layer, [[0, 0, width, height]], gamma);
    return getMainContext().drawImage(layer.canvas, offset.x, offset.y);
  };

  $mainCanvas.mouseup(function(e) {
    return drawing = false;
  });

  $mainCanvas.mousedown(function(e) {
    drawing = true;
    return onDraw(e);
  });

  $mainCanvas.mousemove(function(e) {
    if (drawing) {
      return onDraw(e);
    }
  });

  $('#gammaSlider').slider({
    min: 0,
    max: 4,
    step: 0.01,
    value: gamma,
    change: function(evt, ui) {
      return changeGamma(ui.value);
    }
  });

  fillLayer(layer, function(x, y) {
    return Math.sin(x * y * 10);
  });

  refresh();

}).call(this);
